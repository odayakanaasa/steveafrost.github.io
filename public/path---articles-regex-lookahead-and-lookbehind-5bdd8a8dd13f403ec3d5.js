webpackJsonp([0x6577b0b128cb8000],{"./node_modules/json-loader/index.js!./.cache/json/articles-regex-lookahead-and-lookbehind.json":function(a,s){a.exports={data:{site:{siteMetadata:{title:"Steve Frost – Full Stack Web Developer",author:"Steve Frost"}},markdownRemark:{id:"/Users/stevefrost/Development/Websites/steveafrost.github.io/src/pages/articles/regex-lookahead-and-lookbehind.md absPath of file >>> MarkdownRemark",html:'<p></p>\n<p>Regular Expressions, or regex, is a powerful tool available across several languages to help match patterns. As one <a href="http://blog.teamtreehouse.com/regular-expressions-10-languages">memorable contrast</a> explains, regex is to programming as ‘okay’ is to spoken language – it’s recognized everywhere! It is this universal usability as well as the the common task of having to compare data against a point or pattern that makes regex so prevalent in the development community.</p>\n<p>Since it is used so often, there is plenty of documentation on it though that doesn’t stop the groans from circulating through the room each time regex is mentioned. Personally, I groan because regex teases the head around a problem in a way like no other tool. Also, each time I use it, I have to refresh on exactly how the syntax works since it is unique to regex. For a syntax refresher, I usually pop over to <a href="http://regexr.com">RegExr</a> where they have a cheat sheet and an environment where example data can be manipulated and tested against with custom regex statements.</p>\n<p>Inevitably, after brushing up with the cheat-sheet, I found a novel regex approach that I’ve never seen before. Most recently, I was working with <a href="http://www.fun-with-words.com/pang_example.html">pangrams</a>, sentences that use each letter of the alphabet once, and came across regex’s lookaround behaviors which fit the bill perfectly, as regex usually does. Let’s take a look at what the syntax looks like for these behaviors.</p>\n<h3>Lookarounds</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code># Lookaheads examine what immediately follows the current position\nPositive Lookahead<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span>abc<span class="token punctuation">)</span>\nNegative Lookahead<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">!</span>abc<span class="token punctuation">)</span>\n\n# Lookbehinds examine what immediately precedes the current position\nPositive Lookbehind<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;=</span>abc<span class="token punctuation">)</span>\nNegative Lookbehind<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span>abc<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<h3>In Practice</h3>\n<p>The lookarounds in the above example would help us locate text immediately following or preceding (depending on which we use) a designated string we provide. Let’s use a lookahead to return true if hello if it appears before world but false if followed by any other word.</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code>string1 <span class="token operator">=</span> <span class="token string">\'hello world\'</span>\nstring2 <span class="token operator">=</span> <span class="token string">\'hello steve\'</span>\n\n<span class="token regex">/(hello)(?=\\sworld)/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string1<span class="token punctuation">)</span> #<span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">true</span>\n<span class="token regex">/(hello)(?=\\sworld)/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>string2<span class="token punctuation">)</span> #<span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">false</span>\n</code></pre>\n      </div>\n<p>Our regex here, <code>/(hello)(?=\\sworld)/</code> is explicitly testing each string to see if there is the word, ‘hello’ immediately followed (<code>?=</code> - positive lookahead) by a space (<code>\\s</code>) then the word world. As cool as it is, let’s take this newly acquired knowledge for a spin on a real-world example.</p>\n<h3>Real-World Example</h3>\n<p>Time for a more realistic example – password validation! It is typical to see requirements for a password so how can we check against those? Our fancy new regex lookaheads should help.</p>\n<ul>\n<li>Must contain 8 letters</li>\n<li>Password ends in number</li>\n<li>No special characters allowed</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isValidPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> hasEightLettersThenNum <span class="token operator">=</span> <span class="token regex">/\\w{8}(?=[1-9])/</span>\n  <span class="token keyword">let</span> hasSpecialChars <span class="token operator">=</span> <span class="token operator">/</span><span class="token punctuation">[</span><span class="token operator">^</span>\\w<span class="token punctuation">]</span><span class="token operator">/</span>g  #<span class="token operator">=</span><span class="token operator">></span> g <span class="token keyword">for</span> global search\n\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>hasEightLettersThenNum<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>\n    <span class="token punctuation">(</span>hasSpecialChars<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Valid Password"</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Invalid Password, please see requirements above"</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>As you can see, we were able to use the positive lookahead <code>(?=[1-9])</code> to determine that our password had eight letters followed by a number. This is a fairly contrived example and there are easy ways to check for trailing digits without using a lookahead though this is the general idea &#x26; an applicable use.</p>\n<h3>Conclusion</h3>\n<p>Expanding on &#x26; exercising regex knowledge leads to greater appreciation. Personally, I’ve become more comfortable/daring after a few real-world implementations and I’ve started to recognize that the uses are substantial, varied, and powerful. If you have any go-to uses for regex lookaround, leave them in the comments!</p>',frontmatter:{title:"Applying Regex Lookarounds",date:"May 06, 2017"}}},pathContext:{path:"/articles/regex-lookahead-and-lookbehind"}}}});
//# sourceMappingURL=path---articles-regex-lookahead-and-lookbehind-5bdd8a8dd13f403ec3d5.js.map